<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="MiracleEEEE" />
  <title>Task</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Task</h1>
<p class="author">MiracleEEEE</p>
</header>
<h1 id="知识点补全计划">知识点补全计划</h1>
<h2 id="省选-07">省选 [0/7]</h2>
<h3 id="字符串-46"><span class="todo TODO">TODO</span> 字符串 [4/6]</h3>
<ul>
<li>[X] 后缀数组</li>
<li>[ ] 后缀自动机</li>
<li>[ ] 后缀平衡树</li>
<li>[X] AC自动机</li>
<li>[X] KMP及扩展KMP</li>
<li>[X] manacher</li>
</ul>
<h3 id="图论-317"><span class="todo TODO">TODO</span> 图论 [3/17]</h3>
<ul>
<li>[X] 双连通分量</li>
<li>[ ] 最大流</li>
<li>[ ] 费用流</li>
<li>[ ] 最小割</li>
<li>[ ] 带上下界的网络流</li>
<li>[X] 树剖</li>
<li>[ ] LCT</li>
<li>[X] 点分治</li>
<li>[ ] 边分治</li>
<li>[ ] 动态树分治</li>
<li>[ ] 树分块</li>
<li>[ ] 虚树</li>
<li>[ ] 仙人掌</li>
<li>[ ] 朱刘算法</li>
<li>[ ] 弦图</li>
<li>[ ] 区间图</li>
<li>[ ] 对偶图</li>
</ul>
<h3 id="数学-425"><span class="todo TODO">TODO</span> 数学 [4/25]</h3>
<ul>
<li>[X] 中国剩余定理</li>
<li>[ ] 博弈论</li>
<li>[ ] 拉格朗日乘子法</li>
<li>[ ] 单纯型</li>
<li>[ ] 辛普森积分</li>
<li>[X] 容斥原理</li>
<li>[ ] 莫比乌斯反演</li>
<li>[ ] BSGS</li>
<li>[ ] 置换群</li>
<li>[ ] FFT</li>
<li>[ ] NTT</li>
<li>[ ] 多项式求逆</li>
<li>[ ] 二次剩余</li>
<li>[ ] 多项式科技</li>
<li>[ ] 积分</li>
<li>[ ] 极限</li>
<li>[ ] 微分</li>
<li>[ ] 导数</li>
<li>[ ] Ploya定理</li>
<li>[ ] 贝叶斯定理</li>
<li>[ ] 杜教筛</li>
<li>[ ] Pollard-Rho 圆锥曲线分解法</li>
<li>[X] 线性基</li>
<li>[ ] Miller-Rabin 素性探测</li>
<li>[X] 高斯消元</li>
</ul>
<h3 id="动态规划-26"><span class="todo TODO">TODO</span> 动态规划 [2/6]</h3>
<ul>
<li>[ ] 斜率优化</li>
<li>[ ] 插头DP</li>
<li>[ ] 四边形不等式</li>
<li>[ ] 斯坦纳树</li>
<li>[X] 数位DP</li>
<li>[X] 区间DP</li>
</ul>
<h3 id="计算几何-29"><span class="todo TODO">TODO</span> 计算几何 [2/9]</h3>
<ul>
<li>[X] 基础内容</li>
<li>[ ] 凸包</li>
<li>[ ] 三角剖分</li>
<li>[ ] 旋转卡壳</li>
<li>[ ] 半平面交</li>
<li>[ ] picks定理</li>
<li>[X] 扫描线</li>
<li>[ ] 动态凸包</li>
<li>[ ] 三维计算几何</li>
</ul>
<h3 id="搜索-03"><span class="todo TODO">TODO</span> 搜索 [0/3]</h3>
<ul>
<li>[ ] 模拟退火</li>
<li>[ ] 爬山算法</li>
<li>[ ] 随机增量法</li>
</ul>
<h3 id="数据结构-04"><span class="todo TODO">TODO</span> 数据结构 [0/4]</h3>
<ol>
<li><p><span class="todo TODO">TODO</span> 离线算法 [1/5]</p>
<ul>
<li>[ ] 莫队</li>
<li>[ ] 树上莫队</li>
<li>[ ] 单调莫队</li>
<li>[ ] CDQ分治</li>
<li>[X] 整体二分</li>
</ul></li>
<li><p><span class="todo TODO">TODO</span> 平衡树 [1/3]</p>
<ul>
<li>[ ] rope</li>
<li>[X] Treap</li>
<li>[ ] 替罪羊树</li>
</ul></li>
<li><p><span class="todo TODO">TODO</span> 其他 [1/6]</p>
<ul>
<li>[X] 主席树</li>
<li>[ ] 线段树</li>
<li>[ ] 划分树</li>
<li>[ ] KD-Tree</li>
<li>[ ] 块状链表</li>
<li>[ ] 二维线段树</li>
</ul></li>
<li><p><span class="todo TODO">TODO</span> 可持久化数据结构 [0/5]</p>
<ul>
<li>[ ] 平衡树</li>
<li>[ ] 数组</li>
<li>[ ] Trie树</li>
<li>[ ] 块状链表</li>
<li>[ ] 动态仙人掌</li>
</ul></li>
</ol>
<h1 id="鏼题计划">鏼题计划</h1>
<h2 id="题目泛做">题目泛做</h2>
<h3 id="noip-题目泛做-11">NOIP 题目泛做 [1/1]</h3>
<ol>
<li><p><span class="done DONE">DONE</span> <a href="https://www.luogu.org/problemnew/show/2831">NOIP 2016 愤怒的小鸟</a> &lt;2017-11-24 五&gt; <span class="tag" data-tag-name="状态压缩"><span class="smallcaps">状态压缩</span></span> <span class="tag" data-tag-name="动态规划"><span class="smallcaps">动态规划</span></span></p>
<p><strong>Description</strong></p>
<p>给出<span class="math inline"><em>n</em> ≤ 18</span>个敌人坐标，每次可以可以消灭一条过<span class="math inline">(0, 0)</span>抛物线上的敌人，求最小次数。</p>
<p><strong>Solution</strong></p>
<p><span class="math inline"><em>n</em></span>很小考虑状压。最朴素的动态规划，用<span class="math inline"><em>f</em>[<em>s</em>]</span>表示消灭<span class="math inline"><em>s</em></span>中的敌人的方案数。枚举下一次消灭哪两个敌人，计算抛物线转移，时间复杂度<span class="math inline"><em>O</em>(<em>n</em><sup>32<sup><em>n</em></sup></sup>)</span>，还可以继续优化。我们可以预处理抛物线能消灭哪些敌人，时间复杂度变为<span class="math inline"><em>O</em>(<em>n</em><sup>22<sup><em>n</em></sup></sup>)</span>。但还不够。考虑第一个敌人在这个状态转移的状态中一定被某一条抛物线消灭，这样我们只考虑过第一个敌人的抛物线，枚举其他敌人转移，一定不会丢失最优解。时间复杂度变为<span class="math inline"><em>O</em>(<em>n</em>2<sup><em>n</em></sup>)</span>。</p></li>
</ol>
<h2 id="杂">杂</h2>
<h3 id="年11月-22">2017年11月 [2/2]</h3>
<ol>
<li><p><span class="done DONE">DONE</span> <a href="https://vjudge.net/problem/POJ-3693">POJ 3693 Maximum repetition substring</a> &lt;2017-11-24 五&gt; <span class="tag" data-tag-name="后缀数组"><span class="smallcaps">后缀数组</span></span> <span class="tag" data-tag-name="ST表"><span class="smallcaps">ST表</span></span></p>
<p><strong>Description</strong></p>
<p>给出一个字符串，求最大重复子串（重复次数最多，如果存在多个，求字典序最小的那一个）。</p>
<p><strong>Solution</strong></p>
<p>后缀数组的应用。直接下手不好解决，不妨枚举一下循环节的长度<span class="math inline">|<em>L</em>|</span>。我们发现，任何一个循环节为<span class="math inline">|<em>L</em>|</span>重复子串总会包含至少两个<span class="math inline"><em>s</em>[0],<em>s</em>[|<em>L</em>|], <em>s</em>[2|<em>L</em>|], ⋯</span>字符。那么考虑枚举两个相邻的上述字符，可以通过后缀数组<span class="math inline">+<em>S</em><em>T</em></span>表<span class="math inline"><em>O</em>(1)</span>求出<span class="math inline"><em>L</em><em>C</em><em>P</em></span>的长度，但是最长公共子串的开头并不一定是我们枚举的字符，所以还需要求出最长向前能匹配多少。这可以通过倒过来做一次后缀数组得到。那么我们现在有了一个极长区间，可以求得这个区间的循环节个数<span class="math inline"><em>k</em></span>，也就可以求出一个区间<span class="math inline">[<em>l</em>, <em>r</em>]</span>满足开头落在这个区间内部的最大重复子串的循环节个数都为<span class="math inline"><em>k</em></span>。只需要找字典序最小的一个。那么用<span class="math inline"><em>S</em><em>T</em></span>表查一下这个区间内最小的<span class="math inline"><em>r</em><em>a</em><em>n</em><em>k</em></span>的后缀就好了。时间复杂度<span class="math inline">$O\Big(\sum_{i=1}^{n}\frac{n}{i}\Big)=O(nlogn)$</span>。有一个优化，当求得一个极长重复子串之后，落在子串内的<span class="math inline"><em>s</em>[<em>i</em>|<em>L</em>|]</span>都不用再枚举了。</p></li>
<li><p><span class="done DONE">DONE</span> <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4310">BZOJ 4310 跳蚤</a> &lt;2017-11-29 三&gt; <span class="tag" data-tag-name="后缀数组"><span class="smallcaps">后缀数组</span></span> <span class="tag" data-tag-name="ST表"><span class="smallcaps">ST表</span></span> <span class="tag" data-tag-name="二分查找"><span class="smallcaps">二分查找</span></span></p>
<p><strong>Description</strong></p>
<p>给出一个字符串 <span class="math inline"><em>S</em></span> ，将它分成不超过 <span class="math inline"><em>k</em></span> 个子串，对于每个子串 <span class="math inline"><em>T</em></span> ，设 <span class="math inline"><em>T</em>′</span> 为其最大子串，最小化选出的 <span class="math inline"><em>k</em></span> 个 <span class="math inline"><em>T</em>′<sub><em>i</em></sub></span> 的最大值。</p>
<p><strong>Solution</strong></p>
<p>最大值最小可以二分。可以利用后缀数组求出本质不同的子串个数，对于一个第 <span class="math inline"><em>k</em></span> 大的子串，可以利用后缀数组求出它具体是谁。然后从后向前贪心扫描分块即可。注意一下比较两个串大小时的细节。设第 <span class="math inline"><em>k</em></span> 大的子串和要比较的串在后缀数组中第一次出现的位置分别为为 <span class="math inline"><em>p</em><sub>0</sub>, <em>p</em><sub>1</sub></span> ，分 <span class="math inline"><em>p</em><sub>1</sub> &lt; <em>p</em><sub>0</sub>, <em>p</em><sub>1</sub> = <em>p</em><sub>0</sub>, <em>p</em><sub>1</sub> &gt; <em>p</em><sub>0</sub></span> 三种情况讨论即可。</p></li>
</ol>
<h3 id="年12月-22">2017年12月 [2/2]</h3>
<ol>
<li><p><span class="done DONE">DONE</span> <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3514">BZOJ 3514 Codechef MARCH14 GERALD07加强版</a> &lt;2017-12-06 三&gt; <span class="tag" data-tag-name="LCT"><span class="smallcaps">LCT</span></span> <span class="tag" data-tag-name="主席树"><span class="smallcaps">主席树</span></span> <span class="tag" data-tag-name="贪心"><span class="smallcaps">贪心</span></span></p>
<p><strong>Description</strong></p>
<p>给出一张无向图，每次询问边标号在<span class="math inline">[<em>l</em>, <em>r</em>]</span>区间内的子图的联通块个数。<span class="math inline"><em>N</em> ≤ 200000</span>，强制在线。</p>
<p><strong>Solution</strong></p>
<p>考虑从特殊入手，如果是一棵给出的是一颗树，显然每次询问的答案是<span class="math inline"><em>n</em> − (<em>r</em> − <em>l</em> + 1)</span>，图相比较树的区别是可能会出现环。构成环的边对答案是没有贡献的。如果我们能将每次询问对答案没有贡献的边都找出来，那么就解决了问题。按照编号从小到大依次加边，如果出现了一个环，不妨贪心的将编号最小的那一条边去掉（去掉最小的边不会影响答案！），设最小的那条边的编号为<span class="math inline"><em>k</em></span>，如果<span class="math inline"><em>k</em></span>在<span class="math inline">[<em>l</em>, <em>r</em>]</span>之间，那么现在加的这条边是没有用的，否则如果<span class="math inline"><em>k</em> &lt; <em>l</em></span>，那么这条边有用，对答案有<span class="math inline">−1</span>的贡献。也就是说我们需要求出加入每一条边之后去掉的边是哪一条，可以用一颗<span class="math inline"><em>L</em><em>C</em><em>T</em></span>来维护。对于查询，也就是查区间内小于<span class="math inline"><em>l</em></span>的数字个数，直接上主席树就好了。</p></li>
<li><p><span class="done DONE">DONE</span> <a href="https://arc086.contest.atcoder.jp/tasks/arc086_b">Atcoder Non-decreasing</a> &lt;2017-12-11 一&gt; <span class="tag" data-tag-name="构造"><span class="smallcaps">构造</span></span></p>
<p><strong>Description</strong></p>
<p>给出一个序列<span class="math inline"><em>a</em><sub><em>n</em></sub></span>，每次可以执行操作<span class="math inline"><em>a</em><sub><em>j</em></sub> + =<em>a</em><sub><em>i</em></sub></span>，构造方案使得操作次数<span class="math inline">≤2<em>n</em></span>且数列单调不降。</p>
<p><strong>Solution</strong></p>
<p>不妨从特殊开始考虑，如果这个序列都为正数，那么显然只需要做一次前缀和就满足要求了。现在问题是数列不一定都是正数，那么只需要对每个数加上最大值即可（负数的情况类似讨论）。</p></li>
</ol>
</body>
</html>
